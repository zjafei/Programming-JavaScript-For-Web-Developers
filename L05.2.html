<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title></title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge"/>
    <meta name="renderer" content="webkit">
</head>
<body>
<!--
 * Created by Eric MA
 * Email: zjafei@gmail.com
 * Date: 2015/9/18
 * Time: 10:45
-->
<script type="text/javascript">
    //数组的操作
    //push() 数组尾部添加元素 返回数组长度
    var a0 = new Array();
    console.log(a0.push('1', 2));//2
    console.log(a0.push('3', 4));//4
    console.log(a0);//["1", 2, "3", 4]

    //pop() 删除数组最后一个元素 返回被删除的元素（栈方法 先进后出）
    console.log(a0.pop());//4
    console.log(a0);//["1", 2, "3"]
    console.log(a0.pop());//3
    console.log(a0);//["1", 2]

    //shift() 删除数组的第一个元素 返回被删除的元素（队列方法 先进先出）
    console.log(a0.shift());//1
    console.log(a0);//[2]

    //unshift() 数组头部添加元素 返回数组长度
    console.log(a0.unshift('0', 1));//3
    console.log(a0);//["0", 1, 2]

    //reverse() 方法会反转数组项的顺序 返回数组
    console.log(a0.reverse());//[2, 1, "0"]
    console.log(a0);//[2, 1, "0"]

    //sort() 按升序排列数组项（比较的是元素的字符串值）
    var a1 = ['1', '0', '2', '5', '4', '6', '3', '9', '7', '8', '12', '11', '10'];
    console.log(a1.sort());//["0", "1", "10", "11", "12", "2", "3", "4", "5", "6", "7", "8", "9"]
    console.log(a1);//["0", "1", "10", "11", "12", "2", "3", "4", "5", "6", "7", "8", "9"]
    var a2 = [1, 0, 2, 5, 4, 6, 3, 9, 7, 8, 12, 11, 10];
    console.log(a2.sort());//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 11, 10]
    console.log(a2);//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    // sort()可以接受一个比较的依据
    // 比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果
    // 有了排序依据 排序更灵活了
    console.log(a2.sort(function (v0, v1) {//增序
        if (v0 < v1) {
            return -1;
        } else if (v0 > v1) {
            return 1;
        } else {
            return 0;
        }
    }));
    console.log(a2.sort(function (v0, v1) {//降序
        if (v0 < v1) {
            return 1;
        } else if (v0 > v1) {
            return -1;
        } else {
            return 0;
        }
    }));
    //concat() 数组的拼接
    //在没有参数的情况下只是输出原数组的深拷贝副本
    var a3 = [0, 1, 2];
    var a4 = a3.concat();
    a3[1] = 'a';
    console.log(a3);
    console.log(a4);
    //在有参数的情况下是拼接参数生成一个新数组
    var a5 = a3.concat(a4, 'good');
    console.log(a3);
    console.log(a5);
    //slice() 获取数组的其中一部分
    //第一个参数表示起始位置
    //第二个参数表示结束位置（如果为undefined表示到最后一个元素）
    var a6 = a5.slice(2, 4);
    console.log(a6);
    console.log(a5);
    var a7 = a5.slice(3);
    console.log(a7);
    console.log(a5);
    //splice() 向数组的中插入项
    //第一个参数表示起始位置
    //第二个参数表示要删除的元素
    //第三个参数表示要插入的元素
    var a8 = a5.splice(5);//截取第6个元素到最后一个元素
    console.log(a8);
    console.log(a5);
    var a9 = a5.splice(2, 2);//截取第3个元素开始的2个元素 第二个参数为0就不截取了
    console.log(a9);
    console.log(a5);
    var a10 = a5.splice(1, 2, 'a', 'b', 'c');//第三个参数是插入的元素
    console.log(a10);
    console.log(a5);
    a5.splice(0, 0, '来路', 'ww');//在第一个元素前面插入
    console.log(a5);
    //indexOf() ie8以上才支持
    var a11 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
    console.log(a11.indexOf('d'));//3 永远输出的都是元素在原数组中的位置
    console.log(a11.indexOf('d', 2));//3
    console.log(a11.indexOf('d', 4));//-1 如果起始位置后没有元素则输出-1
    //lastIndexOf() ie8以上才支持
    console.log(a11.lastIndexOf('d'));//3 永远输出的都是元素在原数组中的位置
    console.log(a11.lastIndexOf('d', 2));//开始的位置是从左边算起 但是检索是从右边开始
    console.log(a11.lastIndexOf('d', 3));

    var a12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    //forEach() 没有返回值 只是每项做点什么事
    a12.forEach(function (item, index, array) {
        console.log(item + 1);
    });

    //every() 每一项都返回true才返回true ie8以上才支持
    var b = a12.every(function (item, index, array) {
        return (item > 2);
    });
    console.log(b);
    b = a12.every(function (item, index, array) {//每一项都返回true才返回true
        return (item > -1);
    });
    console.log(b);

    //some() 只要有一项返回true就返回true ie8以上才支持
    b = a12.some(function (item, index, array) {
        return (item > 8);
    });
    console.log(b);
    b = a12.some(function (item, index, array) {//全部返回false才返回false
        return (item < 0);
    });
    console.log(b);

    //map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
    var a13 = a12.map(function (item, index, array) {
        return false;
    });
    console.log(a12);
    console.log(a13);

    //filter() 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组
    var a14 = a12.filter(function (item, index, array) {
        return 1;
    });
    console.log(a12);
    console.log(a14);

    //reduce() 顺序输出结果并在下一个迭代可以使用
    var sum0 = a12.reduce(function (prev, cur, index, array) {
        console.log(index + ':' + prev);//prev是上次输出的结果
        return prev + cur;
    });
    console.log(sum0);
    //reduceRight() 逆顺输出结果并在下一个迭代可以使用
    var sum1 = a12.reduceRight(function (prev, cur, index, array) {
        console.log(index + ':' + prev);//prev是上次输出的结果
        return prev + cur;
    });
    console.log(sum1);

</script>
</body>
</html>